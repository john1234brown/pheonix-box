{"version":3,"file":"pheonixBox.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,cAAc,OAAO;AAC1C;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qBAAqB,cAAc,OAAO;AAC1C;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;;;;;;;;;;;ACpDlC;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,eAAe,mBAAO,CAAC,6BAAQ;AAC/B,kCAAkC,mBAAO,CAAC,wBAAS;AACnD,iCAAiC,mBAAO,CAAC,iCAAU;AACnD,mBAAmB,KAAK;AACxB;AACA;AACA,0BAA0B,aAAa;AACvC,IAAI,+BAA+B;AACnC;AACA;AACA;AACA;AACA,oBAAoB,kFAAkF;AACtG,iEAAiE;AACjE;AACA,kEAAkE;AAClE;AACA,mCAAmC,kFAAkF;AACrH,sGAAsG;AACtG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7Ka;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,wBAAwB,mBAAO,CAAC,cAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,cAAc;;;;;;;;;;;ACtND;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,iBAAiB,mBAAO,CAAC,iCAAU;AACnC,4BAA4B,mBAAO,CAAC,sBAAQ;AAC5C,wBAAwB,mBAAO,CAAC,cAAI;AACpC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,yBAAyB,mBAAO,CAAC,0BAAU,IAAI;AAC/C,eAAe,mBAAO,CAAC,6BAAQ;AAC/B,kCAAkC,mBAAO,CAAC,wBAAS;AACnD,wBAAwB,mBAAO,CAAC,cAAI;AACpC,cAAc,mBAAO,CAAC,2BAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,+BAA+B,aAAa,oBAAoB,SAAS,0BAA0B,UAAU;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,mBAAmB;AAC9F;AACA;AACA;AACA,qBAAqB;AACrB,kCAAkC,6MAA6M;AAC/O;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;;;;;;;;;;AC3Na;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,mBAAO,CAAC,cAAI;AACpC,4BAA4B,mBAAO,CAAC,sBAAQ;AAC5C,0BAA0B,mBAAO,CAAC,kBAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS,6CAA6C,eAAe,MAAM,YAAY;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;AChKf;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://pheonix-box/./src/char.ts","webpack://pheonix-box/./src/cli.ts","webpack://pheonix-box/./src/config.ts","webpack://pheonix-box/./src/main.ts","webpack://pheonix-box/./src/worker.ts","webpack://pheonix-box/external node-commonjs \"cluster\"","webpack://pheonix-box/external node-commonjs \"crypto\"","webpack://pheonix-box/external node-commonjs \"fs\"","webpack://pheonix-box/external node-commonjs \"node:sea\"","webpack://pheonix-box/external node-commonjs \"os\"","webpack://pheonix-box/external node-commonjs \"path\"","webpack://pheonix-box/webpack/bootstrap","webpack://pheonix-box/webpack/before-startup","webpack://pheonix-box/webpack/startup","webpack://pheonix-box/webpack/after-startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateSafeUtf8Characters = generateSafeUtf8Characters;\nexports.generateSafeUtf8CharactersForAES = generateSafeUtf8CharactersForAES;\nfunction generateSafeUtf8Characters(count) {\n    const excludedCharacters = [\n        '\\\\', '`', '$', '\\x1B', '\\uFFFD', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\0',\n        '\\'', '\\\"', '\\u2028', '\\u2029', '\\uD800-\\uDFFF', '\\uFFFE', '\\uFFFF'\n    ]; // Add more exclusions as needed\n    const safeCharacters = [];\n    for (let i = 32; i < 0x10FFFF; i++) { // UTF-8 characters range from 32 to 0x10FFFF\n        if (i >= 0xD800 && i <= 0xDFFF)\n            continue; // Skip surrogate pairs\n        if (i >= 0x7F && i <= 0x9F)\n            continue; // Skip C1 control characters\n        const char = String.fromCodePoint(i);\n        if (!excludedCharacters.includes(char) && char.trim().length > 0) {\n            safeCharacters.push(char);\n        }\n    }\n    for (let i = 0; i < count; i++) {\n        safeCharacters.push('  ');\n    }\n    //    console.log('safeCharacters:', safeCharacters.join(''));\n    console.log('safeCharacters:', safeCharacters.join('').length);\n    return safeCharacters;\n}\nfunction generateSafeUtf8CharactersForAES(count) {\n    const excludedCharacters = [\n        '\\\\', '`', '$', '\\x1B', '\\uFFFD', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\0',\n        '\\'', '\\\"', '\\u2028', '\\u2029', '\\uD800-\\uDFFF', '\\uFFFE', '\\uFFFF'\n    ]; // Add more exclusions as needed\n    const safeCharacters = [];\n    for (let i = 32; i < 0x10FFFF; i++) { // UTF-8 characters range from 32 to 0x10FFFF\n        if (i >= 0xD800 && i <= 0xDFFF)\n            continue; // Skip surrogate pairs\n        if (i >= 0x7F && i <= 0x9F)\n            continue; // Skip C1 control characters\n        const char = String.fromCodePoint(i);\n        if (!excludedCharacters.includes(char) && char.trim().length > 0) {\n            safeCharacters.push(char);\n        }\n    }\n    // AES encryption typically works with bytes, so we need to ensure the characters are within the byte range\n    const aesSafeCharacters = safeCharacters.filter(char => char.charCodeAt(0) <= 0xFF);\n    for (let i = 0; i < count; i++) {\n        //        aesSafeCharacters.push(' ');\n    }\n    //    console.log('aesSafeCharacters:', aesSafeCharacters.join(''));\n    console.log('aesSafeCharacters:', aesSafeCharacters.join('').length);\n    return aesSafeCharacters;\n}\n//console.log(generateSafeUtf8Characters(32)); //Generate with random off spaces of white spaces!\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clusterLock = void 0;\n// Author: Johnathan Edward Brown\n// Purpose: Main entry point for the CLI Pheonix application.\n// Last Modified: 2024-10-13\nconst config_1 = require(\"./config\");\nconst main_1 = require(\"./main\");\nconst cluster_1 = __importDefault(require(\"cluster\"));\nconst worker_1 = __importDefault(require(\"./worker\"));\nexports.clusterLock = { clusterLock: false };\nif (cluster_1.default.isWorker) {\n    // If this is a worker process, do nothing and return early\n    console.log(`Worker ${process.pid} is running`);\n    exports.clusterLock.clusterLock = true;\n    process.on('message', (message) => __awaiter(void 0, void 0, void 0, function* () {\n        const msg = message;\n        if (msg.type === 'start') {\n            console.log('Starting worker process...');\n            const { chunk, config, cipherKey, shuffledKey, aesKey, loaded, fileHashes, fileContents } = message;\n            const worker = new worker_1.default(config, chunk, {}, cipherKey, shuffledKey, aesKey || Buffer.alloc(0), loaded, fileHashes, fileContents);\n            while (true) {\n                const result = yield worker.processFiles(chunk, {});\n                if (process.send)\n                    process.send({ type: 'result', fileHashes: result.fileHashes, fileContents: result.fileContents });\n                yield new Promise(resolve => setTimeout(resolve, config.forkExecutionDelay || 1000)); // Add a configurable delay between executions\n            }\n        }\n    }));\n}\nconst args = process.argv.slice(2);\nif (args.length < 1 || args[0] === 'help') {\n    displayHelp();\n    process.exit(1);\n}\nconst command = args[0];\nconst action = args[1];\nswitch (command) {\n    case 'config':\n        handleConfig(action, args.slice(2));\n        break;\n    case 'start':\n        if (exports.clusterLock.clusterLock === false) {\n            const johnsPheonixBox = new main_1.JohnsPheonixBox();\n            johnsPheonixBox.startProcess(); //Prevent dual executions from cluster modules!\n        }\n        break;\n    default:\n        console.error('Unknown command');\n        displayHelp();\n        process.exit(1);\n}\nfunction handleConfig(action, options) {\n    const config = new config_1.Config();\n    switch (action) {\n        case 'addPath':\n            config.addPath(options[0]);\n            break;\n        case 'removePath':\n            config.removePath(options[0]);\n            break;\n        case 'addFileType':\n            config.addFileType(options[0]);\n            break;\n        case 'removeFileType':\n            config.removeFileType(options[0]);\n            break;\n        case 'addFileRegex':\n            config.addFileRegex(options[0]);\n            break;\n        case 'removeFileRegex':\n            config.removeFileRegex(options[0]);\n            break;\n        case 'setUseFileTypes':\n            config.useFileTypes = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`useFileTypes set to ${options[0]}`);\n            break;\n        case 'setUseFileRegexs':\n            config.useFileRegexs = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`useFileRegexs set to ${options[0]}`);\n            break;\n        case 'setUseCeaserCipher':\n            config.useCeaserCipher = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`useCeaserCipher set to ${options[0]}`);\n            break;\n        case 'setUseAesKey':\n            config.useAesKey = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`useAesKey set to ${options[0]}`);\n            break;\n        case 'setThreads':\n            config.threads = parseInt(options[0], 10);\n            config.saveConfigP();\n            console.log(`threads set to ${options[0]}`);\n            break;\n        case 'setDebug':\n            config.debug = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`debug set to ${options[0]}`);\n            break;\n        case 'setWhiteSpaceOffset':\n            config.whiteSpaceOffset = parseInt(options[0], 10);\n            config.saveConfigP();\n            console.log(`whiteSpaceOffset set to ${options[0]}`);\n            break;\n        case 'addExcludePath':\n            config.addExcludePath(options[0]);\n            break;\n        case 'removeExcludePath':\n            config.removeExcludePath(options[0]);\n            break;\n        case 'setForkDelay':\n            config.forkDelay = parseInt(options[0], 10);\n            config.saveConfigP();\n            console.log(`forkDelay set to ${options[0]}`);\n            break;\n        case 'setForkExecutionDelay':\n            config.forkExecutionDelay = parseInt(options[0], 10);\n            config.saveConfigP();\n            console.log(`forkExecutionDelay set to ${options[0]}`);\n            break;\n        case 'setLocalPathReferences':\n            config.localPathReferences = options[0] === 'true';\n            config.saveConfigP();\n            console.log(`localPathReferences set to ${options[0]}`);\n            break;\n        default:\n            console.error('Unknown config action');\n            displayHelp();\n            process.exit(1);\n    }\n    process.exit(0);\n}\nfunction displayHelp() {\n    console.log('Usage: ./pheonixBox <command> <action> [options]');\n    console.log('Commands:');\n    console.log('  start                      Start the Pheonix process');\n    console.log('  config <action> [options]  Configure the Pheonix settings');\n    console.log('  help                       Display this help message');\n    console.log('Config Actions:');\n    console.log('  addPath <path>             Add a path to the configuration');\n    console.log('  removePath <path>          Remove a path from the configuration');\n    console.log('  addExcludePath <path>      Add a path to the exclude paths');\n    console.log('  removeExcludePath <path>   Remove a path from the exclude paths');\n    console.log('  addFileType <type>         Add a file type to the configuration');\n    console.log('  removeFileType <type>      Remove a file type from the configuration');\n    console.log('  addFileRegex <regex>       Add a file regex to the configuration');\n    console.log('  removeFileRegex <regex>    Remove a file regex from the configuration');\n    console.log('  setUseFileTypes <true|false> Set whether to use file types');\n    console.log('  setUseFileRegexs <true|false> Set whether to use file regexs');\n    console.log('  setUseCeaserCipher <true|false> Set whether to use Ceaser Cipher');\n    console.log('  setUseAesKey <true|false>  Set whether to use AES Key');\n    console.log('  setThreads <number>        Set the number of threads');\n    console.log('  setWhiteSpaceOffset <number> Set the white space offset');\n    console.log('  setForkDelay <number>      Set the fork delay');\n    console.log('  setForkExecutionDelay <number> Set the fork execution delay');\n    console.log('  setDebug <true|false>      Set the debug mode');\n    console.log('  setLocalPathReferences <true|false> Set whether to use local path references');\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Config = void 0;\nconst fs = __importStar(require(\"fs\"));\nclass Config {\n    constructor(configObject) {\n        this.configFilePath = 'configurable.json';\n        this.config = {\n            paths: [],\n            excludePaths: [],\n            fileTypes: [],\n            fileRegexs: [],\n            forkDelay: 1,\n            forkExecutionDelay: 1,\n            threads: 1,\n            useFileTypes: false,\n            useFileRegexs: false,\n            useCeaserCipher: false,\n            useAesKey: false,\n            debug: false,\n            whiteSpaceOffset: 0,\n            localPathReferences: false, // Added here\n        };\n        if (configObject && this.validateConfig(configObject)) {\n            this.config = configObject;\n        }\n        else {\n            this.loadConfig();\n        }\n        this.paths = this.config.paths;\n        this.excludePaths = this.config.excludePaths;\n        this.fileTypes = this.config.fileTypes;\n        this.fileRegexs = this.config.fileRegexs;\n        this.useFileRegexs = this.config.useFileRegexs;\n        this.useFileTypes = this.config.useFileTypes;\n        this.useCeaserCipher = this.config.useCeaserCipher;\n        this.useAesKey = this.config.useAesKey;\n        this.forkDelay = this.config.forkDelay;\n        this.forkExecutionDelay = this.config.forkExecutionDelay;\n        this.threads = this.config.threads;\n        this.debug = this.config.debug;\n        this.whiteSpaceOffset = this.config.whiteSpaceOffset;\n        this.localPathReferences = this.config.localPathReferences; // Added here\n    }\n    log(message) {\n        if (this.debug) {\n            console.log(message);\n        }\n    }\n    saveConfig() {\n        if (this.validateConfig(this.config)) {\n            fs.writeFileSync(this.configFilePath, JSON.stringify(this.config, null, 2));\n            this.log('Configuration saved successfully.');\n        }\n        else {\n            console.error('Invalid configuration. Save aborted.');\n        }\n    }\n    validateConfig(config) {\n        if (!Array.isArray(config.paths))\n            return false;\n        if (!Array.isArray(config.excludePaths))\n            return false;\n        if (!Array.isArray(config.fileTypes))\n            return false;\n        if (!Array.isArray(config.fileRegexs))\n            return false;\n        if (typeof config.useFileTypes !== 'boolean')\n            return false;\n        if (typeof config.useFileRegexs !== 'boolean')\n            return false;\n        if (typeof config.useCeaserCipher !== 'boolean')\n            return false;\n        if (typeof config.useAesKey !== 'boolean')\n            return false;\n        if (typeof config.forkDelay !== 'number')\n            return false;\n        if (typeof config.forkExecutionDelay !== 'number')\n            return false;\n        if (typeof config.threads !== 'number')\n            return false;\n        if (typeof config.debug !== 'boolean')\n            return false;\n        if (typeof config.whiteSpaceOffset !== 'number')\n            return false;\n        if (typeof config.localPathReferences !== 'boolean')\n            return false; // Added here\n        return true;\n    }\n    loadConfig() {\n        if (fs.existsSync(this.configFilePath)) {\n            const loadedConfig = JSON.parse(fs.readFileSync(this.configFilePath, 'utf-8'));\n            if (this.validateConfig(loadedConfig)) {\n                this.config = loadedConfig;\n                this.log('Configuration loaded successfully.');\n            }\n            else {\n                console.error('Invalid configuration file. Loading defaults.');\n                this.config = { paths: [], excludePaths: [], fileTypes: [], fileRegexs: [], useFileTypes: false, useFileRegexs: false, useCeaserCipher: false, useAesKey: false, debug: false, forkDelay: 1, forkExecutionDelay: 1, threads: 1, whiteSpaceOffset: 0, localPathReferences: false };\n            }\n        }\n        else {\n            this.config = { paths: [], excludePaths: [], fileTypes: [], fileRegexs: [], useFileTypes: false, useFileRegexs: false, useCeaserCipher: false, useAesKey: false, debug: false, forkDelay: 1, forkExecutionDelay: 1, threads: 1, whiteSpaceOffset: 0, localPathReferences: false };\n        }\n    }\n    saveConfigP() {\n        const config = {\n            paths: this.paths,\n            excludePaths: this.excludePaths,\n            fileTypes: this.fileTypes,\n            fileRegexs: this.fileRegexs,\n            useFileTypes: this.useFileTypes,\n            useFileRegexs: this.useFileRegexs,\n            useCeaserCipher: this.useCeaserCipher,\n            useAesKey: this.useAesKey,\n            forkDelay: this.forkDelay,\n            forkExecutionDelay: this.forkExecutionDelay,\n            threads: this.threads,\n            debug: this.debug,\n            whiteSpaceOffset: this.whiteSpaceOffset,\n            localPathReferences: this.localPathReferences, // Added here\n        };\n        if (this.validateConfig(config)) {\n            this.config = config;\n            this.saveConfig();\n        }\n        else {\n            console.error('Invalid configuration. Save aborted.');\n        }\n    }\n    addPath(path) {\n        if (!this.config.paths.includes(path)) {\n            this.config.paths.push(path);\n            this.saveConfig();\n            this.log(`Path ${path} added to configuration.`);\n        }\n    }\n    removePath(path) {\n        const index = this.config.paths.indexOf(path);\n        if (index > -1) {\n            this.config.paths.splice(index, 1);\n            this.saveConfig();\n            this.log(`Path ${path} removed from configuration.`);\n        }\n    }\n    addExcludePath(path) {\n        if (!this.config.excludePaths.includes(path)) {\n            this.config.excludePaths.push(path);\n            this.saveConfig();\n            this.log(`Exclude path ${path} added to configuration.`);\n        }\n    }\n    removeExcludePath(path) {\n        const index = this.config.excludePaths.indexOf(path);\n        if (index > -1) {\n            this.config.excludePaths.splice(index, 1);\n            this.saveConfig();\n            this.log(`Exclude path ${path} removed from configuration.`);\n        }\n    }\n    addFileType(fileType) {\n        if (!this.config.fileTypes.includes(fileType)) {\n            this.config.fileTypes.push(fileType);\n            this.saveConfig();\n            this.log(`File type ${fileType} added to configuration.`);\n        }\n    }\n    removeFileType(fileType) {\n        const index = this.config.fileTypes.indexOf(fileType);\n        if (index > -1) {\n            this.config.fileTypes.splice(index, 1);\n            this.saveConfig();\n            this.log(`File type ${fileType} removed from configuration.`);\n        }\n    }\n    addFileRegex(regex) {\n        if (!this.config.fileRegexs.includes(regex)) {\n            this.config.fileRegexs.push(regex);\n            this.saveConfig();\n            this.log(`File regex ${regex} added to configuration.`);\n        }\n    }\n    removeFileRegex(regex) {\n        const index = this.config.fileRegexs.indexOf(regex);\n        if (index > -1) {\n            this.config.fileRegexs.splice(index, 1);\n            this.saveConfig();\n            this.log(`File regex ${regex} removed from configuration.`);\n        }\n    }\n}\nexports.Config = Config;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JohnsPheonixBox = void 0;\nconst config_1 = require(\"./config\");\nconst crypto = __importStar(require(\"crypto\"));\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst sea = __importStar(require(\"node:sea\")); // Assuming 'sea' is a module for handling sea assets\nconst char_1 = require(\"./char\");\nconst cluster_1 = __importDefault(require(\"cluster\"));\nconst os = __importStar(require(\"os\"));\nconst cli_1 = require(\"./cli\");\nconst STATE_FILE_PATH = path.join(process.cwd(), 'pheonixBoxState.json');\nclass JohnsPheonixBox {\n    constructor(useSeaAsset = false, assetLocation = '') {\n        this.fileHashes = {};\n        this.fileContents = {};\n        this.cipherKey = '';\n        this.shuffledKey = '';\n        this.safeAsciiCharacters = [];\n        this.aesKey = null;\n        this.loaded = false;\n        if (useSeaAsset && assetLocation) {\n            this.config = this.loadConfigFromSeaAsset(assetLocation);\n        }\n        else {\n            this.config = new config_1.Config();\n            this.config.saveConfigP();\n            this.loadState();\n        }\n        this.log('Initializing JohnsPheonixBox...');\n        console.log('This loaded:', this.loaded);\n        if (this.loaded === false) {\n            this.safeAsciiCharacters = (0, char_1.generateSafeUtf8Characters)(this.config.whiteSpaceOffset);\n            //            if (this.config.useAesKey)this.safeAsciiCharacters = generateSafeUtf8CharactersForAES(this.config.whiteSpaceOffset);\n            this.cipherKey = this.generateCipherKey();\n            this.shuffledKey = this.cipherKey;\n            if (this.config.useAesKey) {\n                this.aesKey = crypto.randomBytes(32); // Use 256-bit key size\n            }\n        }\n        process.on('exit', (code) => {\n            if (code !== 369) {\n                if (cli_1.clusterLock.clusterLock === false)\n                    this.saveState();\n            }\n        });\n        process.on('SIGINT', () => {\n            if (cli_1.clusterLock.clusterLock === false)\n                this.saveState();\n            process.exit(369);\n        });\n        this.log('JohnsPheonixBox initialized with config:', this.config);\n    }\n    log(...args) {\n        if (this.config.debug) {\n            console.log(...args);\n        }\n    }\n    loadConfigFromSeaAsset(assetLocation) {\n        console.log('Loading config from sea asset:', assetLocation);\n        const arrayBuffer = sea.getAsset(assetLocation);\n        const configString = Buffer.from(arrayBuffer.toString()).toString('utf8');\n        console.log('Loaded config from sea asset:', configString);\n        return JSON.parse(configString);\n    }\n    loadState() {\n        console.log('Loading state from file:', STATE_FILE_PATH);\n        if (fs.existsSync(STATE_FILE_PATH)) {\n            const state = JSON.parse(fs.readFileSync(STATE_FILE_PATH, 'utf-8'));\n            this.cipherKey = state.cipherKey;\n            this.shuffledKey = state.shuffledKey;\n            this.fileHashes = state.fileHashes;\n            this.fileContents = state.fileContents;\n            if (this.config.useAesKey && state.aesKey) {\n                this.aesKey = Buffer.from(state.aesKey, 'hex');\n            }\n            fs.unlinkSync(STATE_FILE_PATH); // Delete the state file after loading\n            this.log('Loaded state:', state);\n            this.loaded = true;\n        }\n    }\n    saveState() {\n        this.log('Saving state to file:', STATE_FILE_PATH);\n        const state = {\n            cipherKey: this.cipherKey,\n            shuffledKey: this.shuffledKey,\n            fileHashes: this.fileHashes,\n            fileContents: this.fileContents\n        };\n        if (this.config.useAesKey && this.aesKey) {\n            state.aesKey = this.aesKey.toString('hex');\n        }\n        fs.writeFileSync(STATE_FILE_PATH, JSON.stringify(state), 'utf-8');\n        this.log('Saved state:', state);\n    }\n    startProcess() {\n        if (cluster_1.default.isPrimary) {\n            let numCPUs = os.cpus().length;\n            if (numCPUs > this.config.threads)\n                numCPUs = this.config.threads; // If configurations for threads is lower than the numCpu threads use that!\n            const fileList = this.getFileList();\n            const chunkSize = Math.ceil(fileList.length / numCPUs);\n            this.log(`Master ${process.pid} is running, using ${numCPUs} threads with chunk size ${chunkSize}`);\n            // Fork workers.\n            let i = 0;\n            const forkWorker = () => {\n                if (i < numCPUs) {\n                    const chunk = fileList.slice(i * chunkSize, (i + 1) * chunkSize);\n                    const worker = cluster_1.default.fork();\n                    worker.on('message', (message) => {\n                        if (message.type === 'result') {\n                            this.log(`Master received result from worker ${worker.process.pid}`);\n                            Object.assign(this.fileHashes, message.fileHashes);\n                            Object.assign(this.fileContents, message.fileContents);\n                        }\n                    });\n                    worker.send({ type: 'start', chunk, config: this.config, cipherKey: this.cipherKey, shuffledKey: this.shuffledKey, aesKey: this.aesKey, loaded: this.loaded, fileHashes: this.fileHashes, fileContents: this.fileContents });\n                    i++;\n                    setTimeout(forkWorker, this.config.forkDelay || 100); // Add a configurable delay between forks\n                }\n            };\n            while (i < numCPUs) {\n                forkWorker();\n            }\n            cluster_1.default.on('exit', (worker, code, signal) => {\n                this.log(`Worker ${worker.process.pid} died`);\n                i = i - 1;\n            });\n        }\n    }\n    getFileList() {\n        this.log('Generating file list...');\n        const fileList = [];\n        const excludePaths = this.config.excludePaths || [];\n        this.config.paths.forEach((filePath) => {\n            if (this.config.localPathReferences) {\n                filePath = path.join(__dirname, filePath);\n            }\n            if (fs.existsSync(filePath)) {\n                const stat = fs.statSync(filePath);\n                if (stat.isDirectory()) {\n                    fs.readdirSync(filePath).forEach(file => {\n                        const fullPath = path.join(filePath, file);\n                        if (!excludePaths.includes(fullPath)) {\n                            fileList.push(fullPath);\n                        }\n                    });\n                }\n                else {\n                    if (!excludePaths.includes(filePath)) {\n                        fileList.push(filePath);\n                    }\n                }\n            }\n        });\n        this.log('Generated file list:', fileList);\n        return fileList;\n    }\n    generateCipherKey() {\n        this.log('Generating cipher key...');\n        const alphabet = this.safeAsciiCharacters;\n        const array = this.shuffleKeys(alphabet);\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = crypto.randomInt(0, i + 1);\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        const cipherKey = array.join('');\n        //        this.log('Generated cipher key:', cipherKey);\n        return cipherKey;\n    }\n    shuffleKeys(array) {\n        this.log('Shuffling key...');\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = crypto.randomInt(0, i + 1);\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        return array;\n    }\n    shuffleKey(key) {\n        this.log('Shuffling key...');\n        const array = key.split('');\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = crypto.randomInt(0, i + 1);\n            [array[i], array[j]] = [array[j], array[i]];\n        }\n        const shuffledKey = array.join('');\n        //        this.log('Shuffled key:', shuffledKey);\n        return shuffledKey;\n    }\n}\nexports.JohnsPheonixBox = JohnsPheonixBox;\n//const johnsPheonixBox = new JohnsPheonixBox();\n//johnsPheonixBox.startProcess();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __importStar(require(\"fs\"));\nconst crypto = __importStar(require(\"crypto\"));\nconst path = __importStar(require(\"path\"));\nclass JohnsWorker {\n    constructor(config, fileList, chunks, cipherKey, shuffledKey, aesKey, loaded, fileHashes, fileContents) {\n        this.config = config;\n        this.loaded = loaded;\n        this.fileHashes = fileHashes || {};\n        this.fileContents = fileContents || {};\n        this.cipherKey = cipherKey;\n        this.shuffledKey = shuffledKey;\n        this.aesKey = aesKey;\n        this.processFiles(fileList, chunks);\n    }\n    log(...args) {\n        if (this.config.debug) {\n            console.log(...args);\n        }\n    }\n    encrypt(text) {\n        this.log('Encrypting text...');\n        const caesarEncrypted = text.split('').map(char => {\n            const index = this.cipherKey.indexOf(char);\n            if (index === -1) {\n                return char;\n            }\n            return this.shuffledKey[index];\n        }).join('');\n        if (this.config.useAesKey && this.aesKey) {\n            const iv = crypto.randomBytes(16); // Initialization vector\n            const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(this.aesKey), iv);\n            let encrypted = cipher.update(caesarEncrypted, 'utf8', 'hex');\n            encrypted += cipher.final('hex');\n            const encryptedWithIv = iv.toString('hex') + ':' + encrypted;\n            this.log('Encrypted text with AES:', encryptedWithIv);\n            return encryptedWithIv;\n        }\n        this.log('Encrypted text with Caesar cipher:', caesarEncrypted);\n        return caesarEncrypted;\n    }\n    decrypt(text) {\n        this.log('Decrypting text...');\n        let decrypted = text;\n        if (this.config.useAesKey && this.aesKey) {\n            const textParts = text.split(':');\n            if (textParts.length < 2) {\n                throw new Error('Invalid encrypted text format');\n            }\n            const iv = Buffer.from(textParts.shift(), 'hex');\n            if (iv.length !== 16) { // AES-256-CBC requires a 16-byte IV\n                throw new Error('Invalid initialization vector length');\n            }\n            const encryptedText = textParts.join(':');\n            const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(this.aesKey), iv);\n            decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n            decrypted += decipher.final('utf8');\n        }\n        const caesarDecrypted = decrypted.split('').map(char => {\n            const index = this.shuffledKey.indexOf(char);\n            if (index === -1) {\n                return char;\n            }\n            return this.cipherKey[index];\n        }).join('');\n        this.log('Decrypted text with Caesar cipher:', caesarDecrypted);\n        return caesarDecrypted;\n    }\n    processFiles(fileList, chunks) {\n        return new Promise((resolve, reject) => {\n            try {\n                this.log('Processing files...');\n                fileList.forEach(filePath => {\n                    this.processFile(filePath, chunks);\n                });\n                resolve({\n                    fileHashes: this.fileHashes,\n                    fileContents: this.fileContents\n                });\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    processFile(filePath, chunks) {\n        this.log('Processing file:', filePath);\n        if (this.shouldProcessFile(filePath)) {\n            const fileContent = fs.readFileSync(filePath, 'utf-8');\n            const fileHash = crypto.createHash('sha256').update(fileContent).digest('hex');\n            if (this.fileHashes[filePath] !== undefined && this.fileContents[filePath] !== undefined) {\n                const storedHash = this.config.useCeaserCipher ? this.decrypt(this.fileHashes[filePath]) : this.fileHashes[filePath];\n                const storedContent = this.config.useCeaserCipher ? this.decrypt(this.fileContents[filePath]) : this.fileContents[filePath];\n                if (!storedHash) {\n                    this.fileHashes[filePath] = this.config.useCeaserCipher ? this.encrypt(fileHash) : fileHash;\n                    this.fileContents[filePath] = this.config.useCeaserCipher ? this.encrypt(fileContent) : fileContent;\n                }\n                else if (storedHash !== fileHash) {\n                    this.log(`File hash mismatch for ${filePath}. Replacing content with stored content. , ${storedContent} \\n, ${fileContent}`);\n                    fs.writeFileSync(filePath, storedContent, 'utf-8');\n                }\n            }\n            else {\n                this.fileHashes[filePath] = this.config.useCeaserCipher ? this.encrypt(fileHash) : fileHash;\n                this.fileContents[filePath] = this.config.useCeaserCipher ? this.encrypt(fileContent) : fileContent;\n            }\n        }\n    }\n    shouldProcessFile(filePath) {\n        var _a, _b, _c;\n        this.log('Checking if file should be processed:', filePath);\n        if ((_a = this.config.excludePaths) === null || _a === void 0 ? void 0 : _a.some(excludePath => filePath.startsWith(excludePath))) {\n            this.log(`File ${filePath} is excluded from processing.`);\n            return false;\n        }\n        if (this.config.useFileTypes) {\n            const fileExtension = path.extname(filePath);\n            if (!((_b = this.config.fileTypes) === null || _b === void 0 ? void 0 : _b.includes(fileExtension))) {\n                return false;\n            }\n        }\n        if (this.config.useFileRegexs) {\n            const fileName = path.basename(filePath);\n            if (!((_c = this.config.fileRegexs) === null || _c === void 0 ? void 0 : _c.some(regex => new RegExp(regex).test(fileName)))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    terminate() {\n        // Implementation of worker termination\n        console.log('Worker terminating...');\n        process.exit(0);\n        console.log('Worker terminated');\n    }\n}\nexports.default = JohnsWorker;\n","module.exports = require(\"cluster\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"node:sea\");","module.exports = require(\"os\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/cli.ts\");\n",""],"names":[],"sourceRoot":""}