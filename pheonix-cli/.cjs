"'use strict';\n\nvar _commonjsHelpers = require('./_commonjsHelpers-CFO10eej.js');\nvar require$$0 = require('fs');\nvar require$$1 = require('crypto');\nvar require$$2 = require('path');\nvar require$$4 = require('node:sea');\nvar require$$7 = require('cluster');\nvar require$$8 = require('os');\n\nvar cli$1 = {};\n\nvar config = {};\n\nvar hasRequiredConfig;\n\nfunction requireConfig () {\n\tif (hasRequiredConfig) return config;\n\thasRequiredConfig = 1;\n\tvar __createBinding = (config && config.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t    }\n\t    Object.defineProperty(o, k2, desc);\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (config && config.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (config && config.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(config, \"__esModule\", { value: true });\n\tconfig.Config = void 0;\n\t/************************************************************************************************************************\n\t * Author: Johnathan Edward Brown                                                                                       *\n\t * Purpose: Configuration class for the CLI Pheonix application.                                                        *\n\t * Last Modified: 2024-10-14                                                                                            *\n\t * License: X11 License                                                                                                 *\n\t * Version: 1.0.4                                                                                                       *\n\t ************************************************************************************************************************/\n\tconst fs = __importStar(require$$0);\n\t/**\n\t * Class representing the configuration settings.\n\t */\n\tclass Config {\n\t    /**\n\t     * Path to the configuration file.\n\t     */\n\t    configFilePath = 'configurable.json';\n\t    /**\n\t     * Configuration object containing various settings.\n\t     */\n\t    config;\n\t    paths;\n\t    excludePaths;\n\t    fileTypes;\n\t    fileRegexs;\n\t    useFileTypes;\n\t    useFileRegexs;\n\t    useCeaserCipher;\n\t    useAesKey;\n\t    forkDelay;\n\t    forkExecutionDelay;\n\t    threads;\n\t    whiteSpaceOffset;\n\t    debug;\n\t    localPathReferences;\n\t    selfTamperProof;\n\t    selfNpmTamperProof;\n\t    /**\n\t     * Creates an instance of Config.\n\t     * @param configObject - Optional configuration object to initialize with.\n\t     */\n\t    constructor(configObject) {\n\t        this.config = {\n\t            paths: [],\n\t            excludePaths: [],\n\t            fileTypes: [],\n\t            fileRegexs: [],\n\t            forkDelay: 1,\n\t            forkExecutionDelay: 1,\n\t            threads: 1,\n\t            useFileTypes: false,\n\t            useFileRegexs: false,\n\t            useCeaserCipher: false,\n\t            useAesKey: false,\n\t            debug: false,\n\t            whiteSpaceOffset: 0,\n\t            localPathReferences: false,\n\t            selfTamperProof: false,\n\t            selfNpmTamperProof: false,\n\t        };\n\t        if (configObject && this.validateConfig(configObject)) {\n\t            this.config = configObject;\n\t        }\n\t        else {\n\t            this.loadConfig();\n\t        }\n\t        this.paths = this.config.paths;\n\t        this.excludePaths = this.config.excludePaths;\n\t        this.fileTypes = this.config.fileTypes;\n\t        this.fileRegexs = this.config.fileRegexs;\n\t        this.useFileRegexs = this.config.useFileRegexs;\n\t        this.useFileTypes = this.config.useFileTypes;\n\t        this.useCeaserCipher = this.config.useCeaserCipher;\n\t        this.useAesKey = this.config.useAesKey;\n\t        this.forkDelay = this.config.forkDelay;\n\t        this.forkExecutionDelay = this.config.forkExecutionDelay;\n\t        this.threads = this.config.threads;\n\t        this.debug = this.config.debug;\n\t        this.whiteSpaceOffset = this.config.whiteSpaceOffset;\n\t        this.localPathReferences = this.config.localPathReferences;\n\t        this.selfTamperProof = this.config.selfTamperProof;\n\t        this.selfNpmTamperProof = this.config.selfNpmTamperProof;\n\t    }\n\t    /**\n\t     * Logs a message if debug mode is enabled.\n\t     * @param message - The message to log.\n\t     */\n\t    log(message) {\n\t        if (this.debug) {\n\t            console.log(message);\n\t        }\n\t    }\n\t    /**\n\t     * Saves the current configuration to the configuration file.\n\t     */\n\t    saveConfig() {\n\t        if (this.config.selfTamperProof || this.config.selfNpmTamperProof) {\n\t            console.error('Configuration is tamper-proof. Save aborted.');\n\t            return;\n\t        }\n\t        if (this.validateConfig(this.config)) {\n\t            fs.writeFileSync(this.configFilePath, JSON.stringify(this.config, null, 2));\n\t            this.log('Configuration saved successfully.');\n\t        }\n\t        else {\n\t            console.error('Invalid configuration. Save aborted.');\n\t        }\n\t    }\n\t    /**\n\t     * Validates the given configuration object.\n\t     * @param config - The configuration object to validate.\n\t     * @returns True if the configuration is valid, false otherwise.\n\t     */\n\t    validateConfig(config) {\n\t        if (!Array.isArray(config.paths))\n\t            return false;\n\t        if (!Array.isArray(config.excludePaths))\n\t            return false;\n\t        if (!Array.isArray(config.fileTypes))\n\t            return false;\n\t        if (!Array.isArray(config.fileRegexs))\n\t            return false;\n\t        if (typeof config.useFileTypes !== 'boolean')\n\t            return false;\n\t        if (typeof config.useFileRegexs !== 'boolean')\n\t            return false;\n\t        if (typeof config.useCeaserCipher !== 'boolean')\n\t            return false;\n\t        if (typeof config.useAesKey !== 'boolean')\n\t            return false;\n\t        if (typeof config.forkDelay !== 'number')\n\t            return false;\n\t        if (typeof config.forkExecutionDelay !== 'number')\n\t            return false;\n\t        if (typeof config.threads !== 'number')\n\t            return false;\n\t        if (typeof config.debug !== 'boolean')\n\t            return false;\n\t        if (typeof config.whiteSpaceOffset !== 'number')\n\t            return false;\n\t        if (typeof config.localPathReferences !== 'boolean')\n\t            return false;\n\t        if (typeof config.selfTamperProof !== 'boolean')\n\t            return false;\n\t        if (typeof config.selfNpmTamperProof !== 'boolean')\n\t            return false;\n\t        return true;\n\t    }\n\t    /**\n\t     * Loads the configuration from the configuration file.\n\t     */\n\t    loadConfig() {\n\t        if (this.config.selfTamperProof || this.config.selfNpmTamperProof) {\n\t            console.error('Configuration is tamper-proof. Load aborted.');\n\t            return;\n\t        }\n\t        if (fs.existsSync(this.configFilePath)) {\n\t            const loadedConfig = JSON.parse(fs.readFileSync(this.configFilePath, 'utf-8'));\n\t            if (this.validateConfig(loadedConfig)) {\n\t                this.config = loadedConfig;\n\t                this.log('Configuration loaded successfully.');\n\t            }\n\t            else {\n\t                console.error('Invalid configuration file. Loading defaults.');\n\t                this.config = { paths: [], excludePaths: [], fileTypes: [], fileRegexs: [], useFileTypes: false, useFileRegexs: false, useCeaserCipher: false, useAesKey: false, debug: false, forkDelay: 1, forkExecutionDelay: 1, threads: 1, whiteSpaceOffset: 0, localPathReferences: false, selfTamperProof: false, selfNpmTamperProof: false };\n\t            }\n\t        }\n\t        else {\n\t            this.config = { paths: [], excludePaths: [], fileTypes: [], fileRegexs: [], useFileTypes: false, useFileRegexs: false, useCeaserCipher: false, useAesKey: false, debug: false, forkDelay: 1, forkExecutionDelay: 1, threads: 1, whiteSpaceOffset: 0, localPathReferences: false, selfTamperProof: false, selfNpmTamperProof: false };\n\t        }\n\t    }\n\t    /**\n\t     * Saves the current configuration to the configuration file.\n\t     * This method is public and updates the internal configuration before saving.\n\t     */\n\t    saveConfigP() {\n\t        const config = {\n\t            paths: this.paths,\n\t            excludePaths: this.excludePaths,\n\t            fileTypes: this.fileTypes,\n\t            fileRegexs: this.fileRegexs,\n\t            useFileTypes: this.useFileTypes,\n\t            useFileRegexs: this.useFileRegexs,\n\t            useCeaserCipher: this.useCeaserCipher,\n\t            useAesKey: this.useAesKey,\n\t            forkDelay: this.forkDelay,\n\t            forkExecutionDelay: this.forkExecutionDelay,\n\t            threads: this.threads,\n\t            debug: this.debug,\n\t            whiteSpaceOffset: this.whiteSpaceOffset,\n\t            localPathReferences: this.localPathReferences,\n\t            selfTamperProof: this.selfTamperProof,\n\t            selfNpmTamperProof: this.selfNpmTamperProof,\n\t        };\n\t        if (this.validateConfig(config)) {\n\t            this.config = config;\n\t            this.saveConfig();\n\t        }\n\t        else {\n\t            console.error('Invalid configuration. Save aborted.');\n\t        }\n\t    }\n\t    /**\n\t     * Adds a path to the configuration.\n\t     * @param path - The path to add.\n\t     */\n\t    addPath(path) {\n\t        if (!this.config.paths.includes(path)) {\n\t            this.config.paths.push(path);\n\t            this.saveConfig();\n\t            this.log(`Path ${path} added to configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Removes a path from the configuration.\n\t     * @param path - The path to remove.\n\t     */\n\t    removePath(path) {\n\t        const index = this.config.paths.indexOf(path);\n\t        if (index > -1) {\n\t            this.config.paths.splice(index, 1);\n\t            this.saveConfig();\n\t            this.log(`Path ${path} removed from configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Adds an exclude path to the configuration.\n\t     * @param path - The exclude path to add.\n\t     */\n\t    addExcludePath(path) {\n\t        if (!this.config.excludePaths.includes(path)) {\n\t            this.config.excludePaths.push(path);\n\t            this.saveConfig();\n\t            this.log(`Exclude path ${path} added to configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Removes an exclude path from the configuration.\n\t     * @param path - The exclude path to remove.\n\t     */\n\t    removeExcludePath(path) {\n\t        const index = this.config.excludePaths.indexOf(path);\n\t        if (index > -1) {\n\t            this.config.excludePaths.splice(index, 1);\n\t            this.saveConfig();\n\t            this.log(`Exclude path ${path} removed from configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Adds a file type to the configuration.\n\t     * @param fileType - The file type to add.\n\t     */\n\t    addFileType(fileType) {\n\t        if (!this.config.fileTypes.includes(fileType)) {\n\t            this.config.fileTypes.push(fileType);\n\t            this.saveConfig();\n\t            this.log(`File type ${fileType} added to configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Removes a file type from the configuration.\n\t     * @param fileType - The file type to remove.\n\t     */\n\t    removeFileType(fileType) {\n\t        const index = this.config.fileTypes.indexOf(fileType);\n\t        if (index > -1) {\n\t            this.config.fileTypes.splice(index, 1);\n\t            this.saveConfig();\n\t            this.log(`File type ${fileType} removed from configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Adds a file regex to the configuration.\n\t     * @param regex - The file regex to add.\n\t     */\n\t    addFileRegex(regex) {\n\t        if (!this.config.fileRegexs.includes(regex)) {\n\t            this.config.fileRegexs.push(regex);\n\t            this.saveConfig();\n\t            this.log(`File regex ${regex} added to configuration.`);\n\t        }\n\t    }\n\t    /**\n\t     * Removes a file regex from the configuration.\n\t     * @param regex - The file regex to remove.\n\t     */\n\t    removeFileRegex(regex) {\n\t        const index = this.config.fileRegexs.indexOf(regex);\n\t        if (index > -1) {\n\t            this.config.fileRegexs.splice(index, 1);\n\t            this.saveConfig();\n\t            this.log(`File regex ${regex} removed from configuration.`);\n\t        }\n\t    }\n\t}\n\tconfig.Config = Config;\n\treturn config;\n}\n\nvar main = {};\n\nvar char = {};\n\nvar hasRequiredChar;\n\nfunction requireChar () {\n\tif (hasRequiredChar) return char;\n\thasRequiredChar = 1;\n\t/************************************************************************************************************************\n\t * Author: Johnathan Edward Brown                                                                                       *\n\t * Purpose: Generate safe UTF-8 characters for use in the PheonixBox Class Object for the CLI Pheonix application.      *\n\t * Last Modified: 2024-10-14                                                                                            *\n\t * License: X11 License                                                                                                 *\n\t * Version: 1.0.4                                                                                                       *\n\t ************************************************************************************************************************/\n\tObject.defineProperty(char, \"__esModule\", { value: true });\n\tchar.generateSafeUtf8Characters = generateSafeUtf8Characters;\n\tchar.generateSafeUtf8CharactersForAES = generateSafeUtf8CharactersForAES;\n\t/**\n\t * Generates an array of safe UTF-8 characters, excluding certain control characters and other specified characters.\n\t *\n\t * @param count - The number of additional spaces to append to the array of safe characters.\n\t * @returns An array of safe UTF-8 characters.\n\t *\n\t * @remarks\n\t * The function excludes characters such as backslashes, backticks, dollar signs, escape characters, and other control characters.\n\t * It also skips surrogate pairs and C1 control characters.\n\t * The resulting characters are filtered to ensure they are within the byte range of the UTF-8 format.\n\t *\n\t * @example\n\t * ```typescript\n\t * const safeChars = generateSafeUtf8Characters(5);\n\t * console.log(safeChars);\n\t * ```\n\t */\n\tfunction generateSafeUtf8Characters(count) {\n\t    const excludedCharacters = [\n\t        '\\\\', '`', '$', '\\x1B', '\\uFFFD', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\0',\n\t        '\\'', '\\\"', '\\u2028', '\\u2029', '\\uD800-\\uDFFF', '\\uFFFE', '\\uFFFF'\n\t    ]; // Add more exclusions as needed\n\t    const safeCharacters = [];\n\t    for (let i = 32; i < 0x10FFFF; i++) { // UTF-8 characters range from 32 to 0x10FFFF\n\t        if (i >= 0xD800 && i <= 0xDFFF)\n\t            continue; // Skip surrogate pairs\n\t        if (i >= 0x7F && i <= 0x9F)\n\t            continue; // Skip C1 control characters\n\t        const char = String.fromCodePoint(i);\n\t        if (!excludedCharacters.includes(char) && char.trim().length > 0) {\n\t            safeCharacters.push(char);\n\t        }\n\t    }\n\t    const aesSafeCharacters = safeCharacters.filter(char => char.charCodeAt(0) <= 0x10FFF); //This ensure safe utf-8 characters are within the byte range of format!\n\t    for (let i = 0; i < count; i++) {\n\t        aesSafeCharacters.push('  ');\n\t    }\n\t    //    console.log('safeCharacters:', safeCharacters.join(''));\n\t    console.log('safeCharacters:', aesSafeCharacters.join('').length);\n\t    return aesSafeCharacters;\n\t}\n\tfunction generateSafeUtf8CharactersForAES(count) {\n\t    const excludedCharacters = [\n\t        '\\\\', '`', '$', '\\x1B', '\\uFFFD', '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\0',\n\t        '\\'', '\\\"', '\\u2028', '\\u2029', '\\uD800-\\uDFFF', '\\uFFFE', '\\uFFFF'\n\t    ]; // Add more exclusions as needed\n\t    const safeCharacters = [];\n\t    for (let i = 32; i < 0x10FFFF; i++) { // UTF-8 characters range from 32 to 0x10FFFF\n\t        if (i >= 0xD800 && i <= 0xDFFF)\n\t            continue; // Skip surrogate pairs\n\t        if (i >= 0x7F && i <= 0x9F)\n\t            continue; // Skip C1 control characters\n\t        const char = String.fromCodePoint(i);\n\t        if (!excludedCharacters.includes(char) && char.trim().length > 0) {\n\t            safeCharacters.push(char);\n\t        }\n\t    }\n\t    // AES encryption typically works with bytes, so we need to ensure the characters are within the byte range\n\t    const aesSafeCharacters = safeCharacters.filter(char => char.charCodeAt(0) <= 0xFFF); //This ensure safe AES characters are within the byte range of format!\n\t    for (let i = 0; i < count; i++) {\n\t        aesSafeCharacters.push('  ');\n\t    }\n\t    //    console.log('aesSafeCharacters:', aesSafeCharacters.join(''));\n\t    console.log('aesSafeCharacters:', aesSafeCharacters.join('').length);\n\t    return aesSafeCharacters;\n\t}\n\t//console.log(generateSafeUtf8Characters(32)); //Generate with random off spaces of white spaces!\n\treturn char;\n}\n\nvar worker = {};\n\nvar hasRequiredWorker;\n\nfunction requireWorker () {\n\tif (hasRequiredWorker) return worker;\n\thasRequiredWorker = 1;\n\tvar __createBinding = (worker && worker.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t    }\n\t    Object.defineProperty(o, k2, desc);\n\t}) : (function(o, m, k, k2) {\n\t    if (k2 === undefined) k2 = k;\n\t    o[k2] = m[k];\n\t}));\n\tvar __setModuleDefault = (worker && worker.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t}) : function(o, v) {\n\t    o[\"default\"] = v;\n\t});\n\tvar __importStar = (worker && worker.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t    __setModuleDefault(result, mod);\n\t    return result;\n\t};\n\tObject.defineProperty(worker, \"__esModule\", { value: true });\n\t/************************************************************************************************************************\n\t * Author: Johnathan Edward Brown                                                                                       *\n\t * Purpose: Worker class for the PheonixBox Class Object for the CLI Pheonix application.                               *\n\t * Last Modified: 2024-10-15                                                                                            *\n\t * License: X11 License                                                                                                 *\n\t * Version: 1.0.4                                                                                                       *\n\t ************************************************************************************************************************/\n\tconst fs = __importStar(require$$0);\n\tconst crypto = __importStar(require$$1);\n\tconst path = __importStar(require$$2);\n\t/**\n\t * The `JohnsWorker` class is responsible for processing files, encrypting, and decrypting their contents.\n\t * It supports both Caesar cipher and AES-256-CBC encryption methods.\n\t *\n\t * @class\n\t * @param {Config} config - Configuration object for the worker.\n\t * @param {string[]} fileList - List of file paths to be processed.\n\t * @param {any} chunks - Data chunks to be processed.\n\t * @param {string} cipherKey - Key used for Caesar cipher encryption.\n\t * @param {string} shuffledKey - Shuffled key used for Caesar cipher decryption.\n\t * @param {Buffer} aesKey - Key used for AES-256-CBC encryption.\n\t * @param {boolean} loaded - Indicates if the worker is loaded.\n\t * @param {FileHashes} [fileHashes] - Optional precomputed file hashes.\n\t * @param {FileContents} [fileContents] - Optional precomputed file contents.\n\t *\n\t * @property {Config} config - Configuration object for the worker.\n\t * @property {FileHashes} fileHashes - Object storing file hashes.\n\t * @property {FileContents} fileContents - Object storing file contents.\n\t * @property {string} cipherKey - Key used for Caesar cipher encryption.\n\t * @property {string} shuffledKey - Shuffled key used for Caesar cipher decryption.\n\t * @property {Buffer} aesKey - Key used for AES-256-CBC encryption.\n\t * @property {boolean} loaded - Indicates if the worker is loaded.\n\t *\n\t * @method log - Logs messages if debug mode is enabled in the config.\n\t * @method encrypt - Encrypts a given text using Caesar cipher and optionally AES-256-CBC.\n\t * @method decrypt - Decrypts a given text using AES-256-CBC and Caesar cipher.\n\t * @method processFiles - Processes a list of files and updates their hashes and contents.\n\t * @method processFile - Processes a single file, updating its hash and content.\n\t * @method shouldProcessFile - Determines if a file should be processed based on the config.\n\t * @method terminate - Terminates the worker process.\n\t */\n\tclass JohnsWorker {\n\t    config;\n\t    fileHashes;\n\t    fileContents;\n\t    cipherKey;\n\t    shuffledKey;\n\t    aesKey;\n\t    loaded;\n\t    constructor(config, fileList, chunks, cipherKey, shuffledKey, aesKey, loaded, fileHashes, fileContents) {\n\t        this.config = config;\n\t        this.loaded = loaded;\n\t        this.fileHashes = fileHashes || {};\n\t        this.fileContents = fileContents || {};\n\t        this.cipherKey = cipherKey;\n\t        this.shuffledKey = shuffledKey;\n\t        this.aesKey = aesKey;\n\t        this.processFiles(fileList, chunks);\n\t    }\n\t    /**\n\t     * Logs messages to the console if debugging is enabled in the configuration.\n\t     *\n\t     * @param {...any[]} args - The messages or objects to log.\n\t     */\n\t    log(...args) {\n\t        if (this.config.debug) {\n\t            console.log(...args);\n\t        }\n\t    }\n\t    /**\n\t     * Encrypts the given text using a Caesar cipher and optionally AES encryption.\n\t     *\n\t     * @param text - The text to be encrypted.\n\t     * @returns The encrypted text. If AES encryption is used, the result will include the initialization vector.\n\t     *\n\t     * @remarks\n\t     * - The method first applies a Caesar cipher using a shuffled key.\n\t     * - If AES encryption is enabled and an AES key is provided, the method further encrypts the result using AES-256-CBC.\n\t     * - Logs the encryption process at various stages.\n\t     */\n\t    encrypt(text) {\n\t        this.log('Encrypting text...');\n\t        const caesarEncrypted = text.split('').map(char => {\n\t            const index = this.cipherKey.indexOf(char);\n\t            if (index === -1) {\n\t                return char;\n\t            }\n\t            return this.shuffledKey[index];\n\t        }).join('');\n\t        if (this.config.useAesKey && this.aesKey) {\n\t            const iv = crypto.randomBytes(16); // Initialization vector\n\t            const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(this.aesKey), iv);\n\t            let encrypted = cipher.update(caesarEncrypted, 'utf8', 'hex');\n\t            encrypted += cipher.final('hex');\n\t            const encryptedWithIv = iv.toString('hex') + ':' + encrypted;\n\t            this.log('Encrypted text with AES:', encryptedWithIv);\n\t            return encryptedWithIv;\n\t        }\n\t        this.log('Encrypted text with Caesar cipher:', caesarEncrypted);\n\t        return caesarEncrypted;\n\t    }\n\t    /**\n\t     * Decrypts the given text using AES-256-CBC and a Caesar cipher.\n\t     *\n\t     * @param text - The encrypted text to decrypt.\n\t     * @returns The decrypted text.\n\t     * @throws {Error} If the encrypted text format is invalid or the initialization vector length is incorrect.\n\t     *\n\t     * The decryption process involves:\n\t     * 1. Logging the start of the decryption process.\n\t     * 2. Checking if AES decryption is enabled and performing AES-256-CBC decryption if applicable.\n\t     * 3. Using a Caesar cipher to further decrypt the text.\n\t     * 4. Logging the decrypted text after applying the Caesar cipher.\n\t     */\n\t    decrypt(text) {\n\t        this.log('Decrypting text...');\n\t        let decrypted = text;\n\t        if (this.config.useAesKey && this.aesKey) {\n\t            const textParts = text.split(':');\n\t            if (textParts.length < 2) {\n\t                throw new Error('Invalid encrypted text format');\n\t            }\n\t            const iv = Buffer.from(textParts.shift(), 'hex');\n\t            if (iv.length !== 16) { // AES-256-CBC requires a 16-byte IV\n\t                throw new Error('Invalid initialization vector length');\n\t            }\n\t            const encryptedText = textParts.join(':');\n\t            const key = this.config.useCeaserCipher ? Buffer.from(this.aesKey) : this.aesKey;\n\t            const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n\t            decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n\t            decrypted += decipher.final('utf8');\n\t        }\n\t        const caesarDecrypted = decrypted.split('').map(char => {\n\t            const index = this.shuffledKey.indexOf(char);\n\t            if (index === -1) {\n\t                return char;\n\t            }\n\t            return this.cipherKey[index];\n\t        }).join('');\n\t        this.log('Decrypted text with Caesar cipher:', caesarDecrypted);\n\t        return caesarDecrypted;\n\t    }\n\t    /**\n\t     * Processes a list of files and returns their hashes and contents.\n\t     *\n\t     * @param fileList - An array of file paths to be processed.\n\t     * @param chunks - Data chunks to be used during file processing.\n\t     * @returns A promise that resolves to an object containing file hashes and file contents.\n\t     * @throws Will reject the promise if an error occurs during file processing.\n\t     */\n\t    processFiles(fileList, chunks) {\n\t        return new Promise((resolve, reject) => {\n\t            try {\n\t                this.log('Processing files...');\n\t                fileList.forEach(filePath => {\n\t                    this.processFile(filePath, chunks);\n\t                });\n\t                resolve({\n\t                    fileHashes: this.fileHashes,\n\t                    fileContents: this.fileContents\n\t                });\n\t            }\n\t            catch (error) {\n\t                reject(error);\n\t            }\n\t        });\n\t    }\n\t    /**\n\t     * Processes a file by reading its content, computing its hash, and comparing it with stored values.\n\t     * If the file should be processed and its hash does not match the stored hash, the file content is replaced\n\t     * with the stored content. The file hash and content can be encrypted/decrypted based on the configuration.\n\t     *\n\t     * @param filePath - The path of the file to process.\n\t     * @param chunks - Additional data or chunks related to the file processing (not used in the current implementation).\n\t     */\n\t    processFile(filePath, chunks) {\n\t        this.log('Processing file:', filePath);\n\t        if (this.shouldProcessFile(filePath)) {\n\t            const fileContent = fs.readFileSync(filePath, 'utf-8');\n\t            const fileHash = crypto.createHash('sha256').update(fileContent).digest('hex');\n\t            if (this.fileHashes[filePath] !== undefined && this.fileContents[filePath] !== undefined) {\n\t                const storedHash = this.config.useCeaserCipher ? this.decrypt(this.fileHashes[filePath]) : this.fileHashes[filePath];\n\t                const storedContent = this.config.useCeaserCipher ? this.decrypt(this.fileContents[filePath]) : this.fileContents[filePath];\n\t                if (!storedHash) {\n\t                    this.fileHashes[filePath] = this.config.useCeaserCipher ? this.encrypt(fileHash) : fileHash;\n\t                    this.fileContents[filePath] = this.config.useCeaserCipher ? this.encrypt(fileContent) : fileContent;\n\t                }\n\t                else if (storedHash !== fileHash) {\n\t                    this.log(`File hash mismatch for ${filePath}. Replacing content with stored content. , ${storedContent} \\n, ${fileContent}`);\n\t                    fs.writeFileSync(filePath, storedContent, 'utf-8');\n\t                }\n\t            }\n\t            else {\n\t                this.fileHashes[filePath] = this.config.useCeaserCipher ? this.encrypt(fileHash) : fileHash;\n\t                this.fileContents[filePath] = this.config.useCeaserCipher ? this.encrypt(fileContent) : fileContent;\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Determines whether a file should be processed based on the configuration settings.\n\t     *\n\t     * @param filePath - The path of the file to check.\n\t     * @returns `true` if the file should be processed, `false` otherwise.\n\t     *\n\t     * The method performs the following checks:\n\t     * - Logs the file path being checked.\n\t     * - Checks if the file path is excluded based on the `excludePaths` configuration.\n\t     * - If `useFileTypes` is enabled, checks if the file extension is included in the `fileTypes` configuration.\n\t     * - If `useFileRegexs` is enabled, checks if the file name matches any of the regular expressions in the `fileRegexs` configuration.\n\t     */\n\t    shouldProcessFile(filePath) {\n\t        this.log('Checking if file should be processed:', filePath);\n\t        if (this.config.excludePaths?.some(excludePath => filePath.startsWith(excludePath))) {\n\t            this.log(`File ${filePath} is excluded from processing.`);\n\t            return false;\n\t        }\n\t        if (this.config.useFileTypes) {\n\t            const fileExtension = path.extname(filePath);\n\t            if (!this.config.fileTypes?.includes(fileExtension)) {\n\t                return false;\n\t            }\n\t        }\n\t        if (this.config.useFileRegexs) {\n\t            const fileName = path.basename(filePath);\n\t            if (!this.config.fileRegexs?.some(regex => new RegExp(regex).test(fileName))) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    /**\n\t     * Terminates the worker process.\n\t     *\n\t     * This method logs a message indicating that the worker is terminating,\n\t     * then exits the process with a status code of 0.\n\t     * Note that any code after `process.exit(0)` will not be executed.\n\t     */\n\t    terminate() {\n\t        // Implementation of worker termination\n\t        console.log('Worker terminating...');\n\t        process.exit(0);\n\t    }\n\t}\n\tworker.default = JohnsWorker;\n\treturn worker;\n}\n\nvar hasRequiredMain;\n\nfunction requireMain () {\n\tif (hasRequiredMain) return main;\n\thasRequiredMain = 1;\n\t(function (exports) {\n\t\tvar __createBinding = (main && main.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    var desc = Object.getOwnPropertyDescriptor(m, k);\n\t\t    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n\t\t      desc = { enumerable: true, get: function() { return m[k]; } };\n\t\t    }\n\t\t    Object.defineProperty(o, k2, desc);\n\t\t}) : (function(o, m, k, k2) {\n\t\t    if (k2 === undefined) k2 = k;\n\t\t    o[k2] = m[k];\n\t\t}));\n\t\tvar __setModuleDefault = (main && main.__setModuleDefault) || (Object.create ? (function(o, v) {\n\t\t    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n\t\t}) : function(o, v) {\n\t\t    o[\"default\"] = v;\n\t\t});\n\t\tvar __importStar = (main && main.__importStar) || function (mod) {\n\t\t    if (mod && mod.__esModule) return mod;\n\t\t    var result = {};\n\t\t    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\t\t    __setModuleDefault(result, mod);\n\t\t    return result;\n\t\t};\n\t\tvar __importDefault = (main && main.__importDefault) || function (mod) {\n\t\t    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n\t\t};\n\t\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t\texports.JohnsPheonixBox = exports.clusterLock = void 0;\n\t\t/************************************************************************************************************************\n\t\t * Author: Johnathan Edward Brown                                                                                       *\n\t\t * Purpose: Main entry point for the PheonixBox Class Object for the CLI Pheonix application.                           *\n\t\t * Last Modified: 2024-10-14                                                                                            *\n\t\t * License: X11 License                                                                                                 *\n\t\t * Version: 1.0.4                                                                                                       *\n\t\t ************************************************************************************************************************/\n\t\tconst config_1 = requireConfig();\n\t\tconst crypto = __importStar(require$$1);\n\t\tconst fs = __importStar(require$$0);\n\t\tconst path = __importStar(require$$2);\n\t\tconst sea = __importStar(require$$4); // Assuming 'sea' is a module for handling sea assets\n\t\tconst char_1 = requireChar();\n\t\tconst worker_1 = __importDefault(requireWorker()); // Import the Worker class from worker.ts\n\t\tconst cluster_1 = __importDefault(require$$7);\n\t\tconst os = __importStar(require$$8);\n\t\texports.clusterLock = { clusterLock: false };\n\t\tif (cluster_1.default.isWorker) {\n\t\t    // If this is a worker process, do nothing and return early\n\t\t    console.log(`Worker ${process.pid} is running`);\n\t\t    exports.clusterLock.clusterLock = true;\n\t\t    process.on('message', async (message) => {\n\t\t        const msg = message;\n\t\t        if (msg.type === 'start') {\n\t\t            console.log('Starting worker process...');\n\t\t            const { chunk, config, cipherKey, shuffledKey, aesKey, loaded, fileHashes, fileContents } = message;\n\t\t            const worker = new worker_1.default(config, chunk, {}, cipherKey, shuffledKey, aesKey || Buffer.alloc(0), loaded, fileHashes, fileContents);\n\t\t            while (true) {\n\t\t                const result = await worker.processFiles(chunk, {});\n\t\t                if (process.send)\n\t\t                    process.send({ type: 'result', fileHashes: result.fileHashes, fileContents: result.fileContents });\n\t\t                await new Promise(resolve => setTimeout(resolve, config.forkExecutionDelay || 1000)); // Add a configurable delay between executions\n\t\t            }\n\t\t        }\n\t\t    });\n\t\t}\n\t\tconst STATE_FILE_PATH = path.join(process.cwd(), 'pheonixBoxState.json');\n\t\t/**\n\t\t * The `JohnsPheonixBox` class provides functionality for managing file hashes, contents, and encryption keys.\n\t\t * It supports runtime protection, state saving/loading, and multi-threaded processing.\n\t\t */\n\t\tclass JohnsPheonixBox {\n\t\t    config;\n\t\t    fileHashes = {};\n\t\t    fileContents = {};\n\t\t    cipherKey = '';\n\t\t    shuffledKey = '';\n\t\t    safeAsciiCharacters = [];\n\t\t    aesKey = null;\n\t\t    loaded;\n\t\t    /**\n\t\t     * Initializes a new instance of the `JohnsPheonixBox` class.\n\t\t     *\n\t\t     * @param {Config} [config] - Optional configuration object.\n\t\t     * @param {boolean} [useSeaAsset=false] - Whether to use a SEA asset for configuration.\n\t\t     * @param {string} [assetLocation=''] - The location of the SEA asset.\n\t\t     */\n\t\t    constructor(config, useSeaAsset = false, assetLocation = '') {\n\t\t        this.loaded = false;\n\t\t        if (config) {\n\t\t            this.config = config;\n\t\t            if (!this.config.selfNpmTamperProof && !this.config.selfTamperProof)\n\t\t                this.config.saveConfigP(); //Prevent Binary Tamper proofing from saving there configurations!\n\t\t            this.loadState();\n\t\t        }\n\t\t        else if (useSeaAsset && assetLocation) {\n\t\t            this.config = this.loadConfigFromSeaAsset(assetLocation);\n\t\t        }\n\t\t        else {\n\t\t            this.config = new config_1.Config();\n\t\t            if (!this.config.selfNpmTamperProof && !this.config.selfTamperProof)\n\t\t                this.config.saveConfigP(); //Prevent Binary Tamper proofing from saving there configurations!\n\t\t            this.loadState();\n\t\t        }\n\t\t        this.log('Initializing JohnsPheonixBox...');\n\t\t        console.log('This loaded:', this.loaded);\n\t\t        if (this.loaded === false) {\n\t\t            this.safeAsciiCharacters = (0, char_1.generateSafeUtf8Characters)(this.config.whiteSpaceOffset);\n\t\t            this.cipherKey = this.generateCipherKey();\n\t\t            this.shuffledKey = this.cipherKey;\n\t\t            if (this.config.useAesKey) {\n\t\t                this.aesKey = crypto.randomBytes(32); // Use 256-bit key size\n\t\t            }\n\t\t        }\n\t\t        process.on('exit', (code) => {\n\t\t            if (code !== 369) {\n\t\t                if (exports.clusterLock.clusterLock === false)\n\t\t                    this.saveState();\n\t\t            }\n\t\t        });\n\t\t        process.on('SIGINT', () => {\n\t\t            if (exports.clusterLock.clusterLock === false)\n\t\t                this.saveState();\n\t\t            process.exit(369);\n\t\t        });\n\t\t        this.log('JohnsPheonixBox initialized with config:', this.config);\n\t\t    }\n\t\t    log(...args) {\n\t\t        if (this.config.debug) {\n\t\t            console.log(...args);\n\t\t        }\n\t\t    }\n\t\t    /**\n\t\t     * Initializes runtime protection for the application.\n\t\t     *\n\t\t     * @param {boolean} [npm] - If true, enables npm tamper-proof protection.\n\t\t     * @param {boolean} [binary] - If true, enables binary tamper-proof protection.\n\t\t     * @param {boolean} [localReferences] - If true, adds local file references to the configuration.\n\t\t     * @param {boolean} [dirname] - If true, uses `__dirname` for path resolution; otherwise, uses `process.cwd()`.\n\t\t     *\n\t\t     * @remarks\n\t\t     * - When `npm` is true, the method configures paths for npm tamper-proof protection.\n\t\t     * - When `binary` is true, the method configures paths for binary tamper-proof protection.\n\t\t     * - If `localReferences` is true, it adds the current file and 'node_modules' to the configuration paths.\n\t\t     * - If `dirname` is true, it uses `__dirname` for path resolution; otherwise, it uses the current working directory.\n\t\t     * - The method ensures that tamper-proof protection is enabled only if it is not already set.\n\t\t     */\n\t\t    initRuntimeProtect(npm, binary, localReferences, dirname) {\n\t\t        if (npm) {\n\t\t            if (!this.config.selfNpmTamperProof) {\n\t\t                this.config.selfNpmTamperProof = true;\n\t\t            }\n\t\t            if (localReferences) {\n\t\t                this.config.addPath(__filename);\n\t\t                this.config.addPath('node_modules');\n\t\t            }\n\t\t            else {\n\t\t                if (dirname) {\n\t\t                    this.config.addPath(path.join(__dirname, __filename));\n\t\t                    this.config.addPath(path.join(__dirname, 'node_modules'));\n\t\t                }\n\t\t                else {\n\t\t                    this.config.addPath(path.join(process.cwd(), __filename));\n\t\t                    this.config.addPath(path.join(process.cwd(), 'node_modules'));\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (binary) {\n\t\t            if (!this.config.selfTamperProof) {\n\t\t                this.config.selfTamperProof = true;\n\t\t            }\n\t\t            if (localReferences) {\n\t\t                this.config.addPath(__filename);\n\t\t            }\n\t\t            else {\n\t\t                if (dirname) {\n\t\t                    this.config.addPath(path.join(__dirname, __filename));\n\t\t                }\n\t\t                else {\n\t\t                    this.config.addPath(path.join(process.cwd(), __filename));\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (localReferences)\n\t\t            this.config.localPathReferences = true;\n\t\t    }\n\t\t    /**\n\t\t     * Loads the configuration from a SEA asset.\n\t\t     *\n\t\t     * @param {string} assetLocation - The location of the SEA asset.\n\t\t     * @returns {Config} The loaded configuration object.\n\t\t     */\n\t\t    loadConfigFromSeaAsset(assetLocation) {\n\t\t        console.log('Loading config from sea asset:', assetLocation);\n\t\t        const arrayBuffer = sea.getAsset(assetLocation);\n\t\t        const configString = Buffer.from(arrayBuffer.toString()).toString('utf8');\n\t\t        console.log('Loaded config from sea asset:', configString);\n\t\t        return JSON.parse(configString);\n\t\t    }\n\t\t    /**\n\t\t     * Loads the state from a file.\n\t\t     */\n\t\t    loadState() {\n\t\t        console.log('Loading state from file:', STATE_FILE_PATH);\n\t\t        if (fs.existsSync(STATE_FILE_PATH)) {\n\t\t            const state = JSON.parse(fs.readFileSync(STATE_FILE_PATH, 'utf-8'));\n\t\t            this.cipherKey = state.cipherKey;\n\t\t            this.shuffledKey = state.shuffledKey;\n\t\t            this.fileHashes = state.fileHashes;\n\t\t            this.fileContents = state.fileContents;\n\t\t            if (this.config.useAesKey && state.aesKey) {\n\t\t                this.aesKey = Buffer.from(state.aesKey, 'hex');\n\t\t            }\n\t\t            fs.unlinkSync(STATE_FILE_PATH); // Delete the state file after loading\n\t\t            this.log('Loaded state:', state);\n\t\t            this.loaded = true;\n\t\t        }\n\t\t    }\n\t\t    /**\n\t\t     * Saves the current state to a file.\n\t\t     */\n\t\t    saveState() {\n\t\t        this.log('Saving state to file:', STATE_FILE_PATH);\n\t\t        const state = {\n\t\t            cipherKey: this.cipherKey,\n\t\t            shuffledKey: this.shuffledKey,\n\t\t            fileHashes: this.fileHashes,\n\t\t            fileContents: this.fileContents\n\t\t        };\n\t\t        if (this.config.useAesKey && this.aesKey) {\n\t\t            state.aesKey = this.aesKey.toString('hex');\n\t\t        }\n\t\t        fs.writeFileSync(STATE_FILE_PATH, JSON.stringify(state), 'utf-8');\n\t\t        this.log('Saved state:', state);\n\t\t    }\n\t\t    /**\n\t\t     * Starts the process, managing worker threads and distributing tasks.\n\t\t     */\n\t\t    startProcess() {\n\t\t        if (cluster_1.default.isPrimary) {\n\t\t            let numCPUs = os.cpus().length;\n\t\t            if (numCPUs > this.config.threads)\n\t\t                numCPUs = this.config.threads; // If configurations for threads is lower than the numCpu threads use that!\n\t\t            const fileList = this.getFileList();\n\t\t            const chunkSize = Math.ceil(fileList.length / numCPUs);\n\t\t            this.log(`Master ${process.pid} is running, using ${numCPUs} threads with chunk size ${chunkSize}`);\n\t\t            // Fork workers.\n\t\t            let i = 0;\n\t\t            const forkWorker = () => {\n\t\t                if (i < numCPUs) {\n\t\t                    const chunk = fileList.slice(i * chunkSize, (i + 1) * chunkSize);\n\t\t                    const worker = cluster_1.default.fork();\n\t\t                    worker.on('message', (message) => {\n\t\t                        if (message.type === 'result') {\n\t\t                            this.log(`Master received result from worker ${worker.process.pid}`);\n\t\t                            Object.assign(this.fileHashes, message.fileHashes);\n\t\t                            Object.assign(this.fileContents, message.fileContents);\n\t\t                        }\n\t\t                    });\n\t\t                    worker.send({ type: 'start', chunk, config: this.config, cipherKey: this.cipherKey, shuffledKey: this.shuffledKey, aesKey: this.aesKey, loaded: this.loaded, fileHashes: this.fileHashes, fileContents: this.fileContents });\n\t\t                    i++;\n\t\t                    setTimeout(forkWorker, this.config.forkDelay || 100); // Add a configurable delay between forks\n\t\t                }\n\t\t            };\n\t\t            while (i < numCPUs) {\n\t\t                forkWorker();\n\t\t            }\n\t\t            cluster_1.default.on('exit', (worker, code, signal) => {\n\t\t                this.log(`Worker ${worker.process.pid} died`);\n\t\t                i = i - 1;\n\t\t            });\n\t\t        }\n\t\t    }\n\t\t    /**\n\t\t     * Generates a list of files to be processed.\n\t\t     *\n\t\t     * @returns {string[]} The list of file paths.\n\t\t     */\n\t\t    getFileList() {\n\t\t        this.log('Generating file list...');\n\t\t        const fileList = [];\n\t\t        const excludePaths = this.config.excludePaths || [];\n\t\t        this.config.paths.forEach((filePath) => {\n\t\t            if (this.config.localPathReferences) {\n\t\t                filePath = path.join(__dirname, filePath);\n\t\t            }\n\t\t            if (fs.existsSync(filePath)) {\n\t\t                const stat = fs.statSync(filePath);\n\t\t                if (stat.isDirectory()) {\n\t\t                    fs.readdirSync(filePath).forEach(file => {\n\t\t                        const fullPath = path.join(filePath, file);\n\t\t                        if (!excludePaths.includes(fullPath)) {\n\t\t                            fileList.push(fullPath);\n\t\t                        }\n\t\t                    });\n\t\t                }\n\t\t                else {\n\t\t                    if (!excludePaths.includes(filePath)) {\n\t\t                        fileList.push(filePath);\n\t\t                    }\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t        if (this.config.selfTamperProof) {\n\t\t            if (fs.existsSync(path.join(__dirname, __filename))) {\n\t\t                fileList.push(path.join(__dirname, __filename));\n\t\t            }\n\t\t            else {\n\t\t                if (fs.existsSync(path.join(process.cwd(), __filename))) {\n\t\t                    fileList.push(path.join(process.cwd(), __filename));\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (this.config.selfNpmTamperProof) {\n\t\t            fileList.push(__dirname);\n\t\t            const npmModulesPath = path.join(__dirname, 'node_modules');\n\t\t            if (fs.existsSync(npmModulesPath)) {\n\t\t                fileList.push(npmModulesPath);\n\t\t            }\n\t\t        }\n\t\t        this.log('Generated file list:', fileList);\n\t\t        return fileList;\n\t\t    }\n\t\t    /**\n\t\t     * Generates a cipher key by shuffling safe ASCII characters.\n\t\t     *\n\t\t     * @returns {string} The generated cipher key.\n\t\t     */\n\t\t    generateCipherKey() {\n\t\t        this.log('Generating cipher key...');\n\t\t        const alphabet = this.safeAsciiCharacters;\n\t\t        const array = this.shuffleKeys(alphabet);\n\t\t        for (let i = array.length - 1; i > 0; i--) {\n\t\t            const j = crypto.randomInt(0, i + 1);\n\t\t            [array[i], array[j]] = [array[j], array[i]];\n\t\t        }\n\t\t        const cipherKey = array.join('');\n\t\t        this.log('Generated cipher key:', cipherKey);\n\t\t        return cipherKey;\n\t\t    }\n\t\t    /**\n\t\t     * Shuffles an array of strings.\n\t\t     *\n\t\t     * @param {string[]} array - The array of strings to shuffle.\n\t\t     * @returns {string[]} The shuffled array.\n\t\t     */\n\t\t    shuffleKeys(array) {\n\t\t        this.log('Shuffling key...');\n\t\t        for (let i = array.length - 1; i > 0; i--) {\n\t\t            const j = crypto.randomInt(0, i + 1);\n\t\t            [array[i], array[j]] = [array[j], array[i]];\n\t\t        }\n\t\t        return array;\n\t\t    }\n\t\t    /**\n\t\t     * Shuffles a given key string.\n\t\t     *\n\t\t     * @param {string} key - The key string to shuffle.\n\t\t     * @returns {string} The shuffled key.\n\t\t     */\n\t\t    shuffleKey(key) {\n\t\t        this.log('Shuffling key...');\n\t\t        const array = key.split('');\n\t\t        for (let i = array.length - 1; i > 0; i--) {\n\t\t            const j = crypto.randomInt(0, i + 1);\n\t\t            [array[i], array[j]] = [array[j], array[i]];\n\t\t        }\n\t\t        const shuffledKey = array.join('');\n\t\t        this.log('Shuffled key:', shuffledKey);\n\t\t        return shuffledKey;\n\t\t    }\n\t\t}\n\t\texports.JohnsPheonixBox = JohnsPheonixBox; \n\t} (main));\n\treturn main;\n}\n\nvar hasRequiredCli;\n\nfunction requireCli () {\n\tif (hasRequiredCli) return cli$1;\n\thasRequiredCli = 1;\n\tObject.defineProperty(cli$1, \"__esModule\", { value: true });\n\t/************************************************************************************************************************\n\t * Author: Johnathan Edward Brown                                                                                       *\n\t * Purpose: CLI with worker thread entry point for the PheonixBox Class Object for the CLI Pheonix application.         *\n\t * Last Modified: 2024-10-14                                                                                            *\n\t * License: X11 License                                                                                                 *\n\t * Version: 1.0.4                                                                                                       *\n\t ************************************************************************************************************************/\n\tconst config_1 = requireConfig();\n\tconst main_1 = requireMain();\n\tconst args = process.argv.slice(2);\n\tif (args.length < 1 || args[0] === 'help') {\n\t    if (main_1.clusterLock.clusterLock === false) {\n\t        displayHelp();\n\t        process.exit(1);\n\t    }\n\t}\n\tconst command = args[0];\n\tconst action = args[1];\n\tswitch (command) {\n\t    case 'config':\n\t        handleConfig(action, args.slice(2));\n\t        break;\n\t    case 'start':\n\t        if (main_1.clusterLock.clusterLock === false) {\n\t            /**\n\t             * An instance of the `JohnsPheonixBox` class.\n\t             * This object is used to interact with the Pheonix Box CLI.\n\t             */\n\t            const johnsPheonixBox = new main_1.JohnsPheonixBox();\n\t            johnsPheonixBox.startProcess(); //Prevent dual executions from cluster modules!\n\t        }\n\t        break;\n\t    default:\n\t        if (main_1.clusterLock.clusterLock === false) {\n\t            console.error('Unknown command');\n\t            displayHelp();\n\t            process.exit(1);\n\t        }\n\t        break;\n\t}\n\t/**\n\t * Handles various configuration actions by invoking corresponding methods on the Config object.\n\t *\n\t * @param action - The configuration action to be performed. Supported actions include:\n\t *   - 'addPath': Adds a path to the configuration.\n\t *   - 'removePath': Removes a path from the configuration.\n\t *   - 'addFileType': Adds a file type to the configuration.\n\t *   - 'removeFileType': Removes a file type from the configuration.\n\t *   - 'addFileRegex': Adds a file regex to the configuration.\n\t *   - 'removeFileRegex': Removes a file regex from the configuration.\n\t *   - 'setUseFileTypes': Sets the useFileTypes flag in the configuration.\n\t *   - 'setUseFileRegexs': Sets the useFileRegexs flag in the configuration.\n\t *   - 'setUseCeaserCipher': Sets the useCeaserCipher flag in the configuration.\n\t *   - 'setUseAesKey': Sets the useAesKey flag in the configuration.\n\t *   - 'setThreads': Sets the number of threads in the configuration.\n\t *   - 'setDebug': Sets the debug flag in the configuration.\n\t *   - 'setWhiteSpaceOffset': Sets the whiteSpaceOffset value in the configuration.\n\t *   - 'addExcludePath': Adds an exclude path to the configuration.\n\t *   - 'removeExcludePath': Removes an exclude path from the configuration.\n\t *   - 'setForkDelay': Sets the fork delay value in the configuration.\n\t *   - 'setForkExecutionDelay': Sets the fork execution delay value in the configuration.\n\t *   - 'setLocalPathReferences': Sets the localPathReferences flag in the configuration.\n\t *   - 'setSelfTamperProof': Sets the selfTamperProof flag in the configuration.\n\t *   - 'setSelfNpmTamperProof': Sets the selfNpmTamperProof flag in the configuration.\n\t *\n\t * @param options - An array of options related to the action. The first element is typically used as the value for the action.\n\t */\n\tfunction handleConfig(action, options) {\n\t    const config = new config_1.Config();\n\t    switch (action) {\n\t        case 'addPath':\n\t            config.addPath(options[0]);\n\t            break;\n\t        case 'removePath':\n\t            config.removePath(options[0]);\n\t            break;\n\t        case 'addFileType':\n\t            config.addFileType(options[0]);\n\t            break;\n\t        case 'removeFileType':\n\t            config.removeFileType(options[0]);\n\t            break;\n\t        case 'addFileRegex':\n\t            config.addFileRegex(options[0]);\n\t            break;\n\t        case 'removeFileRegex':\n\t            config.removeFileRegex(options[0]);\n\t            break;\n\t        case 'setUseFileTypes':\n\t            config.useFileTypes = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`useFileTypes set to ${options[0]}`);\n\t            break;\n\t        case 'setUseFileRegexs':\n\t            config.useFileRegexs = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`useFileRegexs set to ${options[0]}`);\n\t            break;\n\t        case 'setUseCeaserCipher':\n\t            config.useCeaserCipher = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`useCeaserCipher set to ${options[0]}`);\n\t            break;\n\t        case 'setUseAesKey':\n\t            config.useAesKey = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`useAesKey set to ${options[0]}`);\n\t            break;\n\t        case 'setThreads':\n\t            config.threads = parseInt(options[0], 10);\n\t            config.saveConfigP();\n\t            console.log(`threads set to ${options[0]}`);\n\t            break;\n\t        case 'setDebug':\n\t            config.debug = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`debug set to ${options[0]}`);\n\t            break;\n\t        case 'setWhiteSpaceOffset':\n\t            config.whiteSpaceOffset = parseInt(options[0], 10);\n\t            config.saveConfigP();\n\t            console.log(`whiteSpaceOffset set to ${options[0]}`);\n\t            break;\n\t        case 'addExcludePath':\n\t            config.addExcludePath(options[0]);\n\t            break;\n\t        case 'removeExcludePath':\n\t            config.removeExcludePath(options[0]);\n\t            break;\n\t        case 'setForkDelay':\n\t            config.forkDelay = parseInt(options[0], 10);\n\t            config.saveConfigP();\n\t            console.log(`forkDelay set to ${options[0]}`);\n\t            break;\n\t        case 'setForkExecutionDelay':\n\t            config.forkExecutionDelay = parseInt(options[0], 10);\n\t            config.saveConfigP();\n\t            console.log(`forkExecutionDelay set to ${options[0]}`);\n\t            break;\n\t        case 'setLocalPathReferences':\n\t            config.localPathReferences = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`localPathReferences set to ${options[0]}`);\n\t            break;\n\t        case 'setSelfTamperProof':\n\t            config.selfTamperProof = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`selfTamperProof set to ${options[0]}`);\n\t            break;\n\t        case 'setSelfNpmTamperProof':\n\t            config.selfNpmTamperProof = options[0] === 'true';\n\t            config.saveConfigP();\n\t            console.log(`selfNpmTamperProof set to ${options[0]}`);\n\t            break;\n\t        default:\n\t            if (main_1.clusterLock.clusterLock === false) {\n\t                console.error('Unknown config action');\n\t                displayHelp();\n\t                process.exit(1);\n\t            }\n\t    }\n\t    if (main_1.clusterLock.clusterLock === false)\n\t        process.exit(0);\n\t}\n\t/**\n\t * Displays the help message for the Pheonix CLI.\n\t *\n\t * This function outputs the usage instructions and available commands for the Pheonix CLI.\n\t * It includes details on the main commands and their respective actions, as well as configuration options.\n\t *\n\t * Commands:\n\t * - `start`: Start the Pheonix process.\n\t * - `config <action> [options]`: Configure the Pheonix settings.\n\t * - `help`: Display this help message.\n\t *\n\t * Config Actions:\n\t * - `addPath <path>`: Add a path to the configuration.\n\t * - `removePath <path>`: Remove a path from the configuration.\n\t * - `addExcludePath <path>`: Add a path to the exclude paths.\n\t * - `removeExcludePath <path>`: Remove a path from the exclude paths.\n\t * - `addFileType <type>`: Add a file type to the configuration.\n\t * - `removeFileType <type>`: Remove a file type from the configuration.\n\t * - `addFileRegex <regex>`: Add a file regex to the configuration.\n\t * - `removeFileRegex <regex>`: Remove a file regex from the configuration.\n\t * - `setUseFileTypes <true|false>`: Set whether to use file types.\n\t * - `setUseFileRegexs <true|false>`: Set whether to use file regexs.\n\t * - `setUseCeaserCipher <true|false>`: Set whether to use Ceaser Cipher.\n\t * - `setUseAesKey <true|false>`: Set whether to use AES Key.\n\t * - `setThreads <number>`: Set the number of threads.\n\t * - `setWhiteSpaceOffset <number>`: Set the white space offset.\n\t * - `setForkDelay <number>`: Set the fork delay.\n\t * - `setForkExecutionDelay <number>`: Set the fork execution delay.\n\t * - `setDebug <true|false>`: Set the debug mode.\n\t * - `setLocalPathReferences <true|false>`: Set whether to use local path references.\n\t * - `setSelfTamperProof <true|false>`: Set whether to use self tamper proof.\n\t * - `setSelfNpmTamperProof <true|false>`: Set whether to use self npm tamper proof.\n\t */\n\tfunction displayHelp() {\n\t    console.log('Usage: ./pheonixBox <command> <action> [options]');\n\t    console.log('Commands:');\n\t    console.log('  start                      Start the Pheonix process');\n\t    console.log('  config <action> [options]  Configure the Pheonix settings');\n\t    console.log('  help                       Display this help message');\n\t    console.log('Config Actions:');\n\t    console.log('  addPath <path>             Add a path to the configuration');\n\t    console.log('  removePath <path>          Remove a path from the configuration');\n\t    console.log('  addExcludePath <path>      Add a path to the exclude paths');\n\t    console.log('  removeExcludePath <path>   Remove a path from the exclude paths');\n\t    console.log('  addFileType <type>         Add a file type to the configuration');\n\t    console.log('  removeFileType <type>      Remove a file type from the configuration');\n\t    console.log('  addFileRegex <regex>       Add a file regex to the configuration');\n\t    console.log('  removeFileRegex <regex>    Remove a file regex from the configuration');\n\t    console.log('  setUseFileTypes <true|false> Set whether to use file types');\n\t    console.log('  setUseFileRegexs <true|false> Set whether to use file regexs');\n\t    console.log('  setUseCeaserCipher <true|false> Set whether to use Ceaser Cipher');\n\t    console.log('  setUseAesKey <true|false>  Set whether to use AES Key');\n\t    console.log('  setThreads <number>        Set the number of threads');\n\t    console.log('  setWhiteSpaceOffset <number> Set the white space offset');\n\t    console.log('  setForkDelay <number>      Set the fork delay');\n\t    console.log('  setForkExecutionDelay <number> Set the fork execution delay');\n\t    console.log('  setDebug <true|false>      Set the debug mode');\n\t    console.log('  setLocalPathReferences <true|false> Set whether to use local path references');\n\t    console.log('  setSelfTamperProof <true|false> Set whether to use self tamper proof');\n\t    console.log('  setSelfNpmTamperProof <true|false> Set whether to use self npm tamper proof');\n\t}\n\tcli$1.default = main_1.JohnsPheonixBox;\n\treturn cli$1;\n}\n\nvar cliExports = requireCli();\nvar cli = /*@__PURE__*/_commonjsHelpers.getDefaultExportFromCjs(cliExports);\n\nmodule.exports = cli;\n"